Index: src/trunk/apps/processing/scmag/magtool.cpp
===================================================================
--- src/trunk/apps/processing/scmag/magtool.cpp
+++ src/trunk/apps/processing/scmag/magtool.cpp
@@ -176,8 +176,9 @@
 
 
 bool MagTool::init(const MagnitudeTypes &mags, const Core::TimeSpan& expiry) {
+	_cacheSize = expiry;
 	_objectCache.setDatabaseArchive(SCCoreApp->query());
-	_objectCache.setTimeSpan(expiry);
+	_objectCache.setTimeSpan(_cacheSize);
 	_objectCache.setPopCallback(std::bind1st(std::mem_fun(&MagTool::publicObjectRemoved), this));
 
 	_dbAccesses = 0;
@@ -1066,6 +1067,18 @@
 
 		std::list<DataModel::OriginPtr> reloadOrigins;
 
+		// Here we can have a race condition. Imagine the following use case:
+		// - a list of amplitudes is received in one message
+		// - an origin with magnitudes witch reference those amplitudes is being
+		//   send in another message
+		// - the amplitude messages arrives here and we fetch all origins connected
+		//   with an amplitude. the origin itself has not been arrived yet but is already
+		//   stored partly in the database (without e.g. magnitudes). we fetch this
+		//   origin from the database and start to compute magnitudes which are
+		//   probably already part of that origin and will arrive with the next message.
+
+		Core::Time now = Core::Time::GMT();
+
 		DataModel::DatabaseIterator dbit = SCCoreApp->query()->getOriginsForAmplitude(ampl->publicID());
 		for ( ; *dbit; ++dbit ) {
 			DataModel::OriginPtr origin = DataModel::Origin::Cast(*dbit);
@@ -1073,8 +1086,21 @@
 
 			// Did we read the origin directly from DB?
 			if ( !dbit.cached() ) {
+				try {
+					// If origin is not in cache but it was saved to database in less
+					// than cachesize/2 ago we should have received it and thus it
+					// should be in cache. So we ignore this origin and expect it with
+					// a message some time in future.
+					if ( (now - dbit.lastModified()) < Core::TimeSpan(_cacheSize*0.5) ) {
+						SEISCOMP_DEBUG("ignore origin %s: expect its arrival via messaging soon",
+						               origin->publicID().c_str());
+						continue;
+					}
+				}
+				catch ( ... ) {}
+
+				_objectCache.feed(origin.get());
 				reloadOrigins.push_back(origin);
-				_objectCache.feed(origin.get());
 				SEISCOMP_INFO("stored historical origin %s in cache, size = %lu",
 				              origin->publicID().c_str(), (unsigned long)_objectCache.size());
 			}
Index: src/trunk/apps/processing/scmag/magtool.h
===================================================================
--- src/trunk/apps/processing/scmag/magtool.h
+++ src/trunk/apps/processing/scmag/magtool.h
@@ -176,6 +176,7 @@
 		MagnitudeTypes    _magTypes;
 		ProcessorList     _processors;
 		ParameterMap      _parameters;
+		Core::TimeSpan    _cacheSize;
 
 		double            _minimumArrivalWeight;
 		bool              _summaryMagnitudeEnabled;
