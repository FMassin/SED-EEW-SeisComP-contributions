#!/usr/bin/env seiscomp-python
# -*- coding: utf-8 -*-

import sys
import traceback
from seiscomp import client, datamodel
from seiscomp.client import Protocol
from seiscomp.logging import error, warning, debug
from seiscomp.geo import GeoFeatureSet, GeoCoordinate


class EventListener(client.Application):

    def __init__(self, argc, argv):
        client.Application.__init__(self, argc, argv)
        self.setMessagingEnabled(True)
        self.setDatabaseEnabled(False, False)
        self.setPrimaryMessagingGroup(Protocol.LISTENER_GROUP)
        self.addMessagingSubscription("FINDER_ORIGIN")
        self.setLoggingToStdErr(True)


        # The BNA file including all polygons
        try:
            self.bnaFile = self.configGetString('bnaFile')
        except:
            error('Error while reading the bnaFile' )
            sys.exit(-1)
        
        if self.bnaFile.lower() != 'none':
            self.fs = GeoFeatureSet()
            if not self.fs.readBNAFile(self.bnaFile, None):
                error('Impossible to open the bnaFile')
                sys.exit(-1)

        profiles = []
        try:
            profiles = self.configGetStrings('profiles')
        except:
            error('Error while reading the list of profiles.' )
            sys.exit(-1)

        if len(profiles) > 0:
            for name in profiles:
                tmpDic = {}
                tmpDic['name'] = name
                
                # Author of origin and magnitude 
                try:
                    tmpDic['author'] = self.configGetString( 'profile.' + name + '.author')
                except:
                    error('Impossible to parse: '+'profile.' + name + '.author' )
                    sys.exit(-1) 

                # Closed BNA polygon
                try:
                    tmpDic['polygon'] = self.configGetString( 'profile.' + name + '.polygon')
                except:
                    error('Please fix this: Impossible to parse profile.%s.polygon' % name )
                    sys.exit(-1) 
                
                # Check if the polygon is setup 
                if (tmpDic['polygon'] == '' 
                    or tmpDic['polygon'].lower() == 'none' 
                    or self.fs == None):
                    warning("Please fix this: No polygon for profile: "+tmpDic['name'])
                    sys.exit(-1)
                
                # Check if the polygon exists and if it is closed
                try:                   
                    tmpList = list( filter ( lambda x : x.name() == tmpDic['polygon'] and x.closedPolygon() , self.fs.features() ) )        
                except Exception as e:
                    error('There was an error while checking the BNA file')
                    error( repr(e) )
                    sys.exit(-1)
                
                if len(tmpList) == 0:
                    error('Please fix this: Polygon',tmpDic['polygon'],' does not not exist or is not closed in ',self.bnaFile )
                    sys.exit(-1)
                elif len(tmpList) > 1:
                    warning('Please fix this: There are several polygons with the name "%s"' % tmpDic['polygon'])
                    sys.exit(-1)

                tmpList['feature'] = tmpList[0]

                self.profilesDic.append(tmpDic)
                
        else:
            warning('No origin filtering, all the origins will pass.')
            pass

    def geographicCheckOrigin(self, origin):

        try:
            print("origin.publicID = {}".format(origin.publicID()))
            for profile in self.profilesDic:
                debug( 'Evaluation for profile: %s (author: %s, polygon: %s)...' % ( profile['name'], profile['author'], profile['polygon'] ) )

                if origin.creationInfo().author() != profile['author']:
                    continue
                
                coordinates = GeoCoordinate( origin.latitude().value(), 
                                             origin.longitude().value() )
                tmp = ( profile['author'], 
                        origin.latitude().value(), 
                        origin.longitude().value(), 
                        profile['polygon'] )

                if not profile['feature'].contains( coordinates ):
                    debug('%s origin (lat: %s and lon: %s) is not within polygon %s.' % tmp )
                    continue
                else:
                    debug('%s origin (lat: %s and lon: %s) within polygon %s and will be sent.' % tmp )

                # Send the origin if it is in polygon
                self.connection().send(origin)

        except Exception:
            traceback.print_exc()

    def updateObject(self, parentID, scobject):
        # called if an updated object is received
        origin = datamodel.Origin.Cast(scobject)
        if origin:
            print("Received update for origin {}".format(origin.publicID()))
            self.geographicCheckOrigin(origin)

    def addObject(self, parentID, scobject):
        # called if a new object is received
        origin = datamodel.Origin.Cast(scobject)
        if origin:
            print("Received new origin {}".format(origin.publicID()))
            self.geographicCheckOrigin(origin)

    def run(self):
        # does not need to be reimplemented. it is just done to illustrate
        # how to override methods
        print("The origin filter is now running.")
        return client.Application.run(self)


def main():
    app = EventListener(len(sys.argv), sys.argv)
    return app()


if __name__ == "__main__":
    sys.exit(main())